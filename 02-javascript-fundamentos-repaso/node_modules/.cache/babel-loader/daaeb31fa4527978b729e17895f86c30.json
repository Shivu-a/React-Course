{"ast":null,"code":"import \"./index.css\";\nconst arreglo = [1, 2, 3, 4]; // arreglo.push(1);\n// arreglo.push(2);\n// arreglo.push(3);\n// arreglo.push(4);\n// No utilizar el push, utilizar el \"spread\"\n\nlet arreglo2 = [...arreglo, 5]; // los tres puntos ( ... ) es el operador spread\n\nlet arreglo3 = arreglo2.map(x => {\n  return x * 2;\n}); // la funcion .map(), funciona como un for each, pero para crear un nuevo array con los valores despues de pasarlos por una funcion ej: array.map((x)=>{return ${elemento del array} * 2})\n\nconsole.log(arreglo);\nconsole.log(arreglo2);\nconsole.log(arreglo3);","map":{"version":3,"names":["arreglo","arreglo2","arreglo3","map","x","console","log"],"sources":["C:/Users/Iota/Documents/GitHub/React-Cero-A-Experto/02-javascript-fundamentos-repaso/src/index.js"],"sourcesContent":["import \"./index.css\";\r\n\r\nconst arreglo = [1, 2, 3, 4];\r\n// arreglo.push(1);\r\n// arreglo.push(2);\r\n// arreglo.push(3);\r\n// arreglo.push(4);\r\n\r\n// No utilizar el push, utilizar el \"spread\"\r\n\r\nlet arreglo2 = [...arreglo, 5];\r\n// los tres puntos ( ... ) es el operador spread\r\n\r\nlet arreglo3 = arreglo2.map((x) => {\r\n  return x * 2;\r\n});\r\n// la funcion .map(), funciona como un for each, pero para crear un nuevo array con los valores despues de pasarlos por una funcion ej: array.map((x)=>{return ${elemento del array} * 2})\r\n\r\nconsole.log(arreglo);\r\nconsole.log(arreglo2);\r\nconsole.log(arreglo3);\r\n"],"mappings":"AAAA,OAAO,aAAP;AAEA,MAAMA,OAAO,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAhB,C,CACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIC,QAAQ,GAAG,CAAC,GAAGD,OAAJ,EAAa,CAAb,CAAf,C,CACA;;AAEA,IAAIE,QAAQ,GAAGD,QAAQ,CAACE,GAAT,CAAcC,CAAD,IAAO;EACjC,OAAOA,CAAC,GAAG,CAAX;AACD,CAFc,CAAf,C,CAGA;;AAEAC,OAAO,CAACC,GAAR,CAAYN,OAAZ;AACAK,OAAO,CAACC,GAAR,CAAYL,QAAZ;AACAI,OAAO,CAACC,GAAR,CAAYJ,QAAZ"},"metadata":{},"sourceType":"module"}